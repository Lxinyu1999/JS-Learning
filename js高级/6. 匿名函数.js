/**
 * 匿名函数：人如其名，就是没有名称的函数。其中我们常用的箭头函数也算匿名函数的一种
 * 匿名函数的特点是不能单独存在，不能直接调用，也不能只有定义体，它相当于返回一个没有名字的函数的引用
 */
// 错误：直接定义在外面，没有其他操作。
// function(){ // Error：function (Missing)():
//     console.log(10)
// }

// 加上左侧的赋值，就没有问题了，另外在一些老版本的js里面，直接写 fn = function(){}，相当于省略了前面的var，不推荐。
let fn = function () {
  console.log(10);
};

/* 1. 匿名函数的第一种用途：在闭包中作为内层函数被返回 */
function outer() {
  let x;
  // 前面说了匿名函数不能单独存在，但左侧增加return即可存在。
  // 这里你写命名函数（有名函数）也可以，但是没意义，因为都要导出去，到外面接收时还需要命名，就和export一样。
  return function () {
    console.log(x);
  };
}

// 可以和dom操作结合，当然这里运行不了。
// btn.onclick = outer() // 每次点击时都能找到打印同一个x，这个x不会被销毁

/* 2. 匿名函数的第二种用途：作为参数传入到其他函数里面，经常用作回调函数。此时传入的是函数的引用 */
// 最经典的例子是延时器，这里传入的匿名函数不会随着主线程执行，而是等待计时器去调用它
setTimeout(() => {
  // 箭头函数也是匿名函数
  console.log("我不立即执行");
}, 1000);

/* 3. 匿名函数的第三种用途：由于匿名函数不会立即执行，它可以作为外层包装一个需要传参的函数引用
      前面说过了，匿名函数本质是返回一个函数的引用；在传参的时候如果参数是函数，也是传入的是引用。 */
// 直接写fn，没问题，因为是引用。
setTimeout(fn, 1000);

// 但是如果我们想给fn传参呢？以下的写法是错误的，这里的fn会立即执行，因为它是主线程的一部分！
setTimeout(fn(a, b), 1000);

// 怎么办？可以用匿名函数包裹它！因为匿名函数不会立即执行！
setTimeout(() => {
  fn(a, b);
}, 1000);
